# v0.3.0 Planning: Real-World IAM Evaluation + Suite Integration

**Theme:** "This behaves like IAM enough that we can trust CI with it."

**Release tagline:** "Behaves like IAM. Debugs better than GCP."

---

## Decision: Will KMS/Secret Manager call IAM for authz in v0.3.0?

**Options:**

### Option A: Full suite integration (recommended)
- KMS + Secret Manager emulators call IAM emulator via gRPC
- All 3 emulators use shared `IAM_EMULATOR_HOST` env var
- Single `policy.yaml` controls access to all resources
- Docker Compose stack with unified auth

**Pros:**
- Creates "Blackwell GCP local stack" narrative
- Real teams can test complete auth flows locally
- Differentiation: no other emulator suite does this
- Forces us to dogfood our own IAM implementation

**Cons:**
- Need to update KMS + Secret Manager emulators
- More complex integration testing
- Breaking change for users who rely on "allow all" behavior

### Option B: Defer integration to v0.4.0
- v0.3.0 focuses only on IAM policy evaluation quality
- Add conditional bindings, groups, REST gateway, explain mode
- v0.4.0 adds suite integration once IAM is battle-tested

**Pros:**
- Smaller, more focused release
- IAM gets proven standalone first
- No breaking changes to other emulators yet

**Cons:**
- Less compelling "full stack" story
- Teams still need to configure each emulator separately

---

## Recommended v0.3.0 Scope

### 1. IAM-ish Policy Semantics

**Policy schema v2** (backward compatible):
```yaml
projects:
  my-project:
    bindings:  # Changed from "policies"
      - role: roles/secretmanager.admin
        members:
          - serviceAccount:ci@my-project.iam.gserviceaccount.com
        condition:  # NEW
          expression: 'resource.name.startsWith("projects/my-project/secrets/prod-")'
          title: "Prod secrets only"
          description: "CI can only access prod secrets"
```

**Fields to add:**
- `etag` (string): Version identifier for optimistic concurrency
- `version` (int): Policy version (1, 3 for conditions)
- `auditConfig` (list): Audit logging config (store but don't enforce yet)

**Conditional binding evaluation:**
```go
type Condition struct {
    Expression  string  // CEL expression
    Title       string  // Human-readable name
    Description string  // Human-readable description
}

// Evaluate with tiny CEL subset:
// - resource.name.startsWith(prefix)
// - resource.type == "SECRET" | "CRYPTO_KEY"
// - request.time < timestamp("2026-12-31T00:00:00Z")
```

**Deny bindings:**
```yaml
projects:
  my-project:
    bindings:
      - role: roles/secretmanager.admin
        members:
          - group:devs@example.com
      - role: roles/DENY  # NEW
        members:
          - user:intern@example.com
        permissions:
          - secretmanager.secrets.delete
```

---

### 2. Groups

**Config:**
```yaml
groups:
  devs@example.com:
    - user:alice@example.com
    - user:bob@example.com
    - serviceAccount:ci@project.iam.gserviceaccount.com
  
  ci-accounts@example.com:
    - serviceAccount:ci@prod.iam.gserviceaccount.com
    - serviceAccount:ci@staging.iam.gserviceaccount.com

projects:
  my-project:
    bindings:
      - role: roles/secretmanager.admin
        members:
          - group:devs@example.com  # Expands to all group members
```

**Implementation:**
- `principalMatches()` expands groups before checking
- Cache group membership for performance
- Support nested groups (1 level deep)

---

### 3. REST Gateway

**Endpoints:**
```
POST /v1/projects/{project}/secrets/{secret}:setIamPolicy
POST /v1/projects/{project}/secrets/{secret}:getIamPolicy
POST /v1/projects/{project}/secrets/{secret}:testIamPermissions
```

**Implementation:**
- grpc-gateway or custom HTTP handler
- JSON request/response matching GCP format
- Same error codes as gRPC
- Runs on separate port (8081) alongside gRPC (8080)

**Launch:**
```bash
# Dual protocol (like Secret Manager)
server --config policy.yaml --port 8080 --http-port 8081
```

---

### 4. Enhanced Trace Mode

**JSON trace output:**
```bash
server --config policy.yaml --trace --trace-output trace.jsonl
```

**Output format:**
```json
{
  "timestamp": "2026-01-26T10:30:00.123Z",
  "trace_id": "abc123",
  "principal": "serviceAccount:ci@test.iam.gserviceaccount.com",
  "resource": "projects/test/secrets/db-password",
  "permission": "secretmanager.secrets.delete",
  "decision": "DENY",
  "reason": "no matching binding found for principal",
  "checked_bindings": [
    {
      "role": "roles/secretmanager.secretAccessor",
      "members": ["serviceAccount:ci@test.iam.gserviceaccount.com"],
      "has_permission": false,
      "reason": "role does not grant secretmanager.secrets.delete"
    }
  ],
  "conditions_evaluated": [],
  "duration_ms": 0.5
}
```

**Explain mode:**
```bash
server --config policy.yaml --explain
```

Logs every decision with full context (more verbose than --trace).

---

### 5. Emulator Suite Integration (if Option A chosen)

**KMS emulator changes:**
```go
// Before each operation, check IAM
iamClient := iam.NewIAMPolicyClient(iamConn)
resp, err := iamClient.TestIamPermissions(ctx, &iam.TestIamPermissionsRequest{
    Resource: cryptoKeyName,
    Permissions: []string{"cloudkms.cryptoKeys.encrypt"},
})

if len(resp.Permissions) == 0 {
    return status.Error(codes.PermissionDenied, "caller lacks cloudkms.cryptoKeys.encrypt")
}
```

**Environment variable:**
```bash
export IAM_EMULATOR_HOST=localhost:8080
export SECRET_MANAGER_EMULATOR_HOST=localhost:9090
export KMS_EMULATOR_HOST=localhost:9091
```

**Docker Compose:**
```yaml
version: '3'
services:
  iam:
    image: ghcr.io/blackwell-systems/gcp-iam-emulator:v0.3.0
    ports:
      - "8080:8080"
      - "8081:8081"
    volumes:
      - ./policy.yaml:/policy.yaml
    command: --config /policy.yaml --trace --explain

  secret-manager:
    image: ghcr.io/blackwell-systems/gcp-secret-manager-emulator:latest
    environment:
      IAM_EMULATOR_HOST: iam:8080
    ports:
      - "9090:9090"
    depends_on:
      - iam

  kms:
    image: ghcr.io/blackwell-systems/gcp-kms-emulator:latest
    environment:
      IAM_EMULATOR_HOST: iam:8080
    ports:
      - "9091:9090"
    depends_on:
      - iam
```

---

## Implementation Order

1. **Groups** (1-2 days)
   - Add `groups:` section to config
   - Expand in `principalMatches()`
   - Tests for nested groups

2. **Conditional bindings** (3-4 days)
   - Add `Condition` struct to bindings
   - Implement tiny CEL evaluator (resource.name, resource.type, request.time)
   - Trace condition evaluation results

3. **Policy schema v2** (2-3 days)
   - Add etag, version, auditConfig fields
   - Backward compat for old config format
   - Migration guide in docs

4. **REST gateway** (3-4 days)
   - HTTP handler for 3 methods
   - JSON marshaling/unmarshaling
   - Error code mapping
   - Integration tests

5. **Enhanced trace mode** (2-3 days)
   - JSON trace output format
   - --trace-output flag
   - --explain flag (verbose mode)
   - Condition evaluation in traces

6. **Emulator integration** (4-5 days if Option A)
   - Update KMS emulator to call IAM
   - Update Secret Manager emulator to call IAM
   - Docker Compose example
   - End-to-end tests

**Total: 15-21 days without suite integration, 19-26 days with**

---

## Success Criteria

v0.3.0 is successful if:

1. ✅ Teams can use conditional bindings for real-world policies
2. ✅ Trace output explains "why denied" better than GCP
3. ✅ REST gateway unlocks non-Go clients
4. ✅ Groups reduce policy file duplication
5. ✅ (If Option A) Full stack works in Docker Compose with unified auth

---

## Open Question for User

**Should v0.3.0 include emulator suite integration (Option A) or defer to v0.4.0 (Option B)?**

My recommendation: **Option A** - it's the differentiation story and forces us to prove IAM works in real usage.
